二叉树说明
------------------
树主要是二叉树较多，其中用到的知识点也就是广度优先搜索(BFS)和深度优先搜索(DFS)

- 广度优先搜索，借助于队列的数据结构，从而保证树的结点是按照层数打印的，每执行完一层，才会进行到下一层
- 深度优先搜索，可以使用递归或者栈来记录遍历过程中访问过的父节点

树主要有三种遍历方式：前序， 中序和后序，三种遍历都可以用递归和非递归方式

伪代码

```c++
// 前序
void preorder(TreeNode* root) {
    if(root == nullptr) return;
    cout << root->val << " ";
    preorder(root->left);
    preorder(root->right);
}

void preorder_norecursion(TreeNode* root) {
    stack<TreeNode*> s;
    while(root != nullptr || !s.emtpy()) {
        while(root != nullptr) {
            cout << root->val << " ";
            s.push(root);
            root = root->left;
        }
        if (!s.empty()) {
            root = s.top();
            s.pop();
            root = root->right;
        }
    }
}

// 中序
void inorder(TreeNode* root) {
    if(root == nullptr) return;
    inorder(root->left);
    cout << root->val << " ";
    inorder(root->right);
}

void inorder_norecursion(TreeNode* root) {
    stack<TreeNode*> s;
    while(root != nullptr || !s.empty()) {
        while(root != nullptr) {
            s.push(root);
            root = root->left;
        }
        root = s.top();
        s.pop();
        cout << root->val << " ";
        root = root->right;
    }
}

// 后序
void postorder(TreeNode* root) {
    if(root == nullptr) return;
    postorder(root->left);
    postorder(root->right);
    cout << root->val << " ";
}

void postorder_norecursion(TreeNode* root) {
    stack<TreeNode*> s;
    TreeNode* cur = root;
    TreeNode* last = nullptr;
    while(cur != nullptr) {
        s.push(cur);
        cur = cur->left;
    }
    while(!empty()) {
        cur = s.top();
        s.pop();
        if(cur->right == nullptr || cur->right == last) {
            cout << cur->val << " ";
            last = cur;
        } else {
            s.push(cur);
            cur = cur->right;
            while(cur != nullptr) {
                s.push(cur);
                cur = cur->left;
            }
        }
    }
}
```

深度优先和广度优先

```c++
void dfs(TreeNode* root) {
    if (root == nullptr) return;
    // 处理数据
    dfs(root->left);
    dfs(root->right);
}

void bfs(TreeNode* root) {
    if (root == nullptr) return;
    queue<TreeNode*> q;
    q.push(root);
    while(!q.empyt()) {
        int sz = q.size();
        for(int i = 0; i < sz; i++) {
            TreeNode* t = q.front();
            q.pop();
            // 处理数据
            if (t->left != nullptr) q.push(t->left);
            if (t->right != nullptr) q.push(t->right);
        }
    }
}
```


94 Binary Tree Inorder Traversal
-------------------
[LeetCode](https://leetcode.com/problems/binary-tree-inorder-traversal)/[力扣](https://leetcode-cn.com/problems/binary-tree-inorder-traversal)

Given the root of a binary tree, return the inorder traversal of its nodes' values. 

直接上述中序遍历代码就好

```c++
vector<int> inorderTraversal(TreeNode* root) {
    vector<int> ans;
    inorder(root, ans);
    return ans;
}
void inorder(TreeNode* root, vector<int>& ans) {
    if (root == nullptr) return;
    inorder(root->left, ans);
    ans.push_back(root->val);
    inorder(root->right, ans);
}
```