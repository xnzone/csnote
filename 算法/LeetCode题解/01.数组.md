数组问题说明
------------
数组问题一般没有什么特殊的技巧，需要大量的练习，跟字符串的问题类似，不好控制。

一般都有一个暴力解法，如果没有思路，需要写出暴力解法

1 Two Sum
---------------------
[LeetCode]()/[力扣]()

Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target

用map保存已经遍历过的数字

```c++
vector<int> twoSum(vector<int>& nums, int target) {
    map<int, int> m;
    for(int i = 0; i < nums.size(); i++) {
        if (map[target - nums[i]] != 0) {
            return {m[target-nums[i]] - 1, i};
        }
        m[nums[i]] = i + 1;
    }
    return {};
}
```

31 Next Permutation
---------------------
[LeetCode]()/[力扣]()

Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.

这道题比较晦涩难懂，实际上的要求就是找到这个数组排列的下一个更大的数字。主要思路是

1. 从后往前找，找到截至递增的序列，记序号为idx，此时从idx到end是递减的序列
2. 接下来要从idx到end中找到一个比idx-1的数字大，但是两个差值最小的值，记做序号ich
3. 交换idx-1和ich
4. 把从idx到end进行排序

```c++
void nextPermutation(vector<int>& nums) {
    int idx = nums.size() - 1;
    while(idx > 0) {
        if(nums[idx] > nums[idx - 1]) break;
        idx--;
    }
    if (idx == 0) {
        reverse(nums.begin(), nums.end());
        return;
    }
    int ich = -1;
    for(int i = nums.size() - 1; i >= idx; i--) {
        if(nums[i] > nums[idx - 1]) {
            ich = i;
            break;
        }
    }
    swap(nums[idx - 1], nums[ich]);
    sort(nums.begin() + idx, nums.end());
}
```

48 Rotate Image
----------
[LeetCode]()/[力扣]()

You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).

这个旋转可以看作先上下颠倒，然后把数组中i,j位置对换

```c++
void rotate(vector<vector<int>>& matrix) {
    reverse(matrix.begin(), matrix.end());
    for(int i = 0; i < matrix.size(); i++) {
        for(int j = i; j < matrix[i].size(); j++) {
            swap(matrix[i][j], matrix[j][i]);
        }
    }
}
```