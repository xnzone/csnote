# 解题要点
此类型的题目，没有固定的模式，只能看自己的经验

其中每道题都存在一种暴力解法，如果实在没有更好的解法，可以尝试暴力解法。面试中如果暂时想不出题解，一定要尝试使用暴力解法得到答案

# 题目摘要
## 41 First Missing Positive
[LeetCode](https://leetcode.com/problems/first-missing-positive/)/[力扣](https://leetcode-cn.com/problems/first-missing-positive/)

给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。

```html
输入：nums = [1,2,0]
输出：3

输入：nums = [3,4,-1,1]
输出：2
```

**题解**
```go
func firstMissingPositive(nums []int) int {
    helper := make([]int, len(nums)+1)
    for _, h := range helper {
        h = 1
    }
    for _, num := range nums {
        if num > len(nums) || num <= 0 {
            continue
        }
        helper[num] = 0
    }
    for i := range helper {
        if helper[i] == 1 {
            return i
        }
    }
    return len(nums) + 1
}
```

## Rotate Image
[LeetCode](https://leetcode.com/problems/rotate-image)/[力扣](https://leetcode-cn.com/problems/rotate-image)

```html
Given input matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],
rotate the input matrix in-place such that it becomes:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
```

**题解**
分层旋转，每次旋转交换4个数，用一个中间变量保存其中一个数就可以，一层旋转完了再往里层循环，直到层数大于n/2,需要注意判断特殊情况
```go
func rotate(matrix [][]int) {
    n := len(matrix)
    layer := 0
    for layer < n / 2 {
        for i := 0; i < n - 2 * layer - 1; i++ {
            tmp := matrix[layer][layer + i]
            matrix[layer][i + layer] = matrix[n - layer -i - 1][layer];
            matrix[n - layer - i - 1][layer] = matrix[n - layer - 1][n - layer -i - 1];
            matrix[n - layer - 1][n - layer - i - 1] = matrix[layer + i][n - layer - 1];
            matrix[layer + i][n - layer - 1] = tmp;
        }
        layer++
    }
}
```