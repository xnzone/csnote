1 Two Sum
---------------------
[LeetCode]()/[力扣]()

Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target

用map保存已经遍历过的数字

```c++
vector<int> twoSum(vector<int>& nums, int target) {
    map<int, int> m;
    for(int i = 0; i < nums.size(); i++) {
        if (map[target - nums[i]] != 0) {
            return {m[target-nums[i]] - 1, i};
        }
        m[nums[i]] = i + 1;
    }
    return {};
}
```

31 Next Permutation
---------------------
[LeetCode]()/[力扣]()

Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.

这道题比较晦涩难懂，实际上的要求就是找到这个数组排列的下一个更大的数字。主要思路是

1. 从后往前找，找到截至递增的序列，记序号为idx，此时从idx到end是递减的序列
2. 接下来要从idx到end中找到一个比idx-1的数字大，但是两个差值最小的值，记做序号ich
3. 交换idx-1和ich
4. 把从idx到end进行排序

```c++
void nextPermutation(vector<int>& nums) {
    int idx = nums.size() - 1;
    while(idx > 0) {
        if(nums[idx] > nums[idx - 1]) break;
        idx--;
    }
    if (idx == 0) {
        reverse(nums.begin(), nums.end());
        return;
    }
    int ich = -1;
    for(int i = nums.size() - 1; i >= idx; i--) {
        if(nums[i] > nums[idx - 1]) {
            ich = i;
            break;
        }
    }
    swap(nums[idx - 1], nums[ich]);
    sort(nums.begin() + idx, nums.end());
}
```