动态规划说明
-------------
动态规划主要是要找到状态转移方程，其它都是很好办的。可以参考高中学过的数学归纳法来找状态转移方程，比如假设第i个是什么， 然后找到i+1和i之间的关系就可以了


32 Longest Valid Parentheses
----------------------
[LeetCode]()/[力扣]()

Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring. 

使用动态规划求解，但是状态转移方程比较绕

- 数组dp的第i个元素表示下标为i的字符结尾最长有效字符串的长度
- s[i] == '('时 dp[i] = 0。因为无法与之前的组成有效长度
- s[i] == ')'时，需要分两种情况看，
  - 1. s[i-1] == '('， 此时s[i-1]和s[i]组成有效字符'()', 此时dp[i] = dp[i-2] + 2
  - 2. s[i-1] == ')', 此时要考虑s[i-1]之间的有效长度之前一位是否匹配，即s[i-dp[i-1]-1] 是否等于 '('， 如果相等，则dp[i] = dp[i-1] + 2 + dp[i-dp[i-1]-2]

```c++
int longestValidParentheses(string s) {
    vector<int> dp(s.size(), 0);
    int ans = 0;
    for(int i = 0; i < s.size(); i++) {
        if(s[i] == '(') continue;
        if(s[i-1] == '(') {
            dp[i] = i >= 2 ? dp[i-2] + 2:2; 
        } else {
            int idx = i - dp[i-1] - 1;
            if(idx>=0 && s[idx] == '(') {
                dp[i] = idx >= 1 ? dp[i-1]+2+dp[idx-1]:dp[i-1]+2;
            }
        }
        ans = max(ans, dp[i]);
    }
    return ans;
}
```

53 Maximum Subarray
-------------------------
[LeetCode]()/[力扣]()

Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. 

- 假设dp[i]为第i个数的最大值， 那么dp[i+1] = max(dp[i] + nums[i + 1], nums[i + 1])
- 最后的结果就是dp中的最大值

```c++
int maxSubArray(vector<int>& nums) {
    if(nums.size() <= 0) return 0;
    vector<int> dp(nums.size(), 0);
    dp[0] = 0;
    for(int i = 1; i < nums.size(); i++) {
        dp[i] = max(dp[i-1] + nums[i], nums[i]);
    }
    int ans = dp[0];
    for(int i = 1; i < dp.size(); i++) {
        ans = max(dp[i], ans);
    }
    return ans;
}
```