32 Longest Valid Parentheses
----------------------
[LeetCode]()/[力扣]()

Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring. 

使用动态规划求解，但是状态转移方程比较绕

- 数组dp的第i个元素表示下标为i的字符结尾最长有效字符串的长度
- s[i] == '('时 dp[i] = 0。因为无法与之前的组成有效长度
- s[i] == ')'时，需要分两种情况看，
  - 1. s[i-1] == '('， 此时s[i-1]和s[i]组成有效字符'()', 此时dp[i] = dp[i-2] + 2
  - 2. s[i-1] == ')', 此时要考虑s[i-1]之间的有效长度之前一位是否匹配，即s[i-dp[i-1]-1] 是否等于 '('， 如果相等，则dp[i] = dp[i-1] + 2 + dp[i-dp[i-1]-2]

```c++
int longestValidParentheses(string s) {
    vector<int> dp(s.size(), 0);
    int ans = 0;
    for(int i = 0; i < s.size(); i++) {
        if(s[i] == '(') continue;
        if(s[i-1] == '(') {
            dp[i] = i >= 2 ? dp[i-2] + 2:2; 
        } else {
            int idx = i - dp[i-1] - 1;
            if(idx>=0 && s[idx] == '(') {
                dp[i] = idx >= 1 ? dp[i-1]+2+dp[idx-1]:dp[i-1]+2;
            }
        }
        ans = max(ans, dp[i]);
    }
    return ans;
}
```