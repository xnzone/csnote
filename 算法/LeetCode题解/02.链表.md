# 解题要点
翻转链表的某个节点，通常要求原地操作，不使用额外的空间

主要原理就是用多个指针去定义变量，然后进行翻转。

通常需要保存处理当前节点的上一个节点，不然反转就会丢失链表信息，指向前一个节点后，需要更新当前节点和上一个节点位置，进行下一次遍历

![](https://gitee.com/ixnzone/img-bed/raw/master/2020/12/20201219173024.png)

# 题目摘要
## 24. 两两交换链表中的节点
[LeetCode](https://leetcode.com/problems/swap-nodes-in-pairs)/[力扣](https://leetcode-cn.com/problems/swap-nodes-in-pairs)

给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

**示例**
```html
输入：head = [1,2,3,4]
输出：[2,1,4,3]
```
**题解**

邻近两个交换后，直接递归下一次循环。非递归可以看做先把前一个删除再插入到后面一个节点，分两步操作
```go
func swapPairs(head *ListNode) *ListNode {
    if head != nil && head.Next != nil {
        head.Val, head.Next.Val = head.Next.Val, head.Val
        swapPairs(head.Next.Next)
    }
    return head
}
```

## 25. K 个一组翻转链表
[LeetCode](https://leetcode.com/problems/reverse-nodes-in-k-group)/[力扣](https://leetcode-cn.com/problems/reverse-nodes-in-k-group)

给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。

k 是一个正整数，它的值小于或等于链表的长度。

如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

**示例**
```html
给你这个链表：1->2->3->4->5
当 k = 2 时，应当返回: 2->1->4->3->5
当 k = 3 时，应当返回: 3->2->1->4->5
```

**题解**

算法本身并不复杂，但是过程模拟比较复杂，代码较长。可以看做中间的链表反转，只需要记住前面和后面的指针即可，最后拼接三个链表
```go
func reverseKGroup(head *ListNode, k int) *ListNode {
    po := ListNode{Val: 0}
    p := &po
    prev := p
    cur := head
    cend := nextNode(head, k)
    if cend == nil {
        return head
    }
    next := cend.Next

    for cur != nil {
        cend.Next = nil
        rcur := reverse(cur)
        prev.Next = rcur
        prev = cur
        cur = next
        cend = nextNode(next, k)
        if cend == nil {
            prev.Next = next
            next = nil
            break
        } else {
            next = cend.Next
        }
    }
    return p.Next
}

func nextNode(node *ListNode, k int) *ListNode{
    for i := 0; i < k-1; i++ {
        if node == nil {
            return node
        }
        node = node.Next
    }
    return node
}

func reverse(head *ListNode) *ListNode {
    var prev *ListNode
    cur := head
    for cur != nil {
        next := cur.Next
        cur.Next = prev
        prev = cur
        cur = next
    }
    return prev
}
```

## 61. 旋转链表
[LeetCode](https://leetcode.com/problems/rotate-list)/[力扣](https://leetcode-cn.com/problems/rotate-list)

给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。

```html
输入: 1->2->3->4->5->NULL, k = 2
输出: 4->5->1->2->3->NULL
解释:
向右旋转 1 步: 5->1->2->3->4->NULL
向右旋转 2 步: 4->5->1->2->3->NULL
```

**题解**

旋转链表，先记录总长度，然后根据总长度与k的余数，再看从哪里开始放到链表头部
```go
func rotateRight(head *ListNode, k int) *ListNode {
    if head == nil || k == 0 {
        return head
    }
    n := 0
    phead := head
    pend := head
    for pend.Next != nil {
        n++
        pend = pend.Next
    }
    k = (n + 1) - k % (n + 1)
    for i := 0; i < k -1; i++ {
        phead = phead.Next
    }
    pend.Next = head
    res := phead.Next
    phead.Next = nil
    return res
}
```

## 206. 反转链表
[LeetCode](https://leetcode.com/problems/reverse-linked-list)/[力扣](https://leetcode-cn.com/problems/reverse-linked-list)

反转一个单链表。

```html
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```

**题解**

反转链表，经典题目，不过多解释了
```go
func reverseList(head *ListNode) *ListNode {
    var prev *ListNode
    cur := head
    for cur != nil {
        next := cur.Next
        cur.Next = prev
        prev = cur
        cur = next
    }
    return prev
}
```

## 92. 反转链表 II
[LeetCode](https://leetcode.com/problems/reverse-linked-list-ii)/[力扣](https://leetcode-cn.com/problems/reverse-linked-list-ii)

反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。

```html
输入: 1->2->3->4->5->NULL, m = 2, n = 4
输出: 1->4->3->2->5->NULL
```

**题解**

参考反转链表，将`prev`替换成`nil`就可以了

```go
func reverseBetween(head *ListNode, m int, n int) *ListNode {
    if head == nil {
        return head
    }
    p := &ListNode{Val: 0}
    p.Next = head
    begin, end := p, p
    for i := 0; i < n; i++ {
        if i == m -1 {
            begin = end
        }
        end = end.Next
    }
    begin.Next = reverse(begin.Next, end.Next)
    return p.Next

}

func reverse(begin *ListNode, end *ListNode) *ListNode {
    if begin == end {
        return begin
    }
    prev := end
    cur := begin
    for cur != end {
        next := cur.Next
        cur.Next = prev
        prev = cur
        cur = next
    }
    return prev
}
```

## 328. 奇偶链表
[LeetCode](https://leetcode.com/problems/odd-even-linked-list)/[力扣](https://leetcode-cn.com/problems/odd-even-linked-list)

给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。

请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。

```html
输入: 1->2->3->4->5->NULL
输出: 1->3->5->2->4->NULL
```

**题解**

用两个指针来保存奇偶不同的链表，然后把偶指针加到奇指针末尾
```go
func oddEvenList(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
    odd := head
    even := head.Next
    eh := head.Next
    for even != nil && even.Next != nil {
        odd.Next = even.Next
        odd = odd.Next
        even.Next = odd.Next
        even = even.Next
    }
    odd.Next = eh
    return head
}
```