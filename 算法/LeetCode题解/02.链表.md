# 解题要点
翻转链表的某个节点，通常要求原地操作，不使用额外的空间

主要原理就是用多个指针去定义变量，然后进行翻转。

通常需要保存处理当前节点的上一个节点，不然反转就会丢失链表信息，指向前一个节点后，需要更新当前节点和上一个节点位置，进行下一次遍历

![](https://gitee.com/ixnzone/img-bed/raw/master/2020/12/20201219173024.png)

# 题目摘要
## 24. 两两交换链表中的节点

给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

**示例**
```html
输入：head = [1,2,3,4]
输出：[2,1,4,3]
```
**题解**

邻近两个交换后，直接递归下一次循环。非递归可以看做先把前一个删除再插入到后面一个节点，分两步操作
```go
func swapPairs(head *ListNode) *ListNode {
    if head != nil && head.Next != nil {
        head.Val, head.Next.Val = head.Next.Val, head.Val
        swapPairs(head.Next.Next)
    }
    return head
}
```

## 25. K 个一组翻转链表
给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。

k 是一个正整数，它的值小于或等于链表的长度。

如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

**示例**
```html
给你这个链表：1->2->3->4->5
当 k = 2 时，应当返回: 2->1->4->3->5
当 k = 3 时，应当返回: 3->2->1->4->5
```

**题解**

算法本身并不复杂，但是过程模拟比较复杂，代码较长。可以看做中间的链表反转，只需要记住前面和后面的指针即可，最后拼接三个链表
```go
func reverseKGroup(head *ListNode, k int) *ListNode {
    po := ListNode{Val: 0}
    p := &po
    prev := p
    cur := head
    cend := nextNode(head, k)
    if cend == nil {
        return head
    }
    next := cend.Next

    for cur != nil {
        cend.Next = nil
        rcur := reverse(cur)
        prev.Next = rcur
        prev = cur
        cur = next
        cend = nextNode(next, k)
        if cend == nil {
            prev.Next = next
            next = nil
            break
        } else {
            next = cend.Next
        }
    }
    return p.Next
}

func nextNode(node *ListNode, k int) *ListNode{
    for i := 0; i < k-1; i++ {
        if node == nil {
            return node
        }
        node = node.Next
    }
    return node
}

func reverse(head *ListNode) *ListNode {
    var prev *ListNode
    cur := head
    for cur != nil {
        next := cur.Next
        cur.Next = prev
        prev = cur
        cur = next
    }
    return prev
}
```