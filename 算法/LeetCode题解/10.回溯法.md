回溯法说明
-------------------
主要用于深度优先搜索时，如果不满足条件，需要回溯的方式，一般采用递归的方式进行

主要的思路是先不管满足不满足条件，把其中可能的结果压入，等到单个递归结束时，需要把之前的压入的弹出即可

伪代码
```c++
void backtrack(void* candicates, void* target, void* path, void* ans) {
    if(meet demand target) {
        save the answer
    }
    push candicate to path solution
    backtrack();
    pop candicate
}
```

22 Generate Parentheses
-------------------
[LeetCode](https://leetcode.com/problems/generate-parentheses)/[力扣](https://leetcode-cn.com/problems/generate-parentheses)
Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses

纯递归

```c++
vector<string> generateParenthesis(int n) {
    vector<string> ans;
    dfs("", n, n);
    return ans;
}
void dfs(string s, int left, int right) {
    if (left == 0 && right == 0) ans.push_back(s);
    if(left > 0) dfs(s + '(', left - 1, right, ans);
    if (left < right) dfs(s+')', left, right - 1, ans);
}
```

回溯
```c++
vector<char> c = {'(', ')'};
vector<string> generateParenthesis(int n) {
    vector<string> ans;
    string s = "";
    helper(s,0, n, ans);
    return ans;
}
void helper(string& s,int idx, int len, vector<string>& ans) {
    if (s.size() == len * 2) {
        ans.push_back(s);
        return;
    }

    for(int i = 0; i < c.size(); i++) {
        if (s.size() - idx >= idx && i == 1) continue;
        if (idx <= 0 && i == 1) continue;
        if (idx >= len && i == 0) continue;
        s.push_back(c[i]);
        if (i == 0) idx++;
        helper(s,idx, len, ans);
        if (i == 0) idx--;
        s.pop_back();
    }
}
```


39 Combination Sum
--------------------
[LeetCode](https://leetcode.com/problems/combination-sum)/[力扣](https://leetcode-cn.com/problems/combination-sum)


Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order. 

常规的回溯法求解，并没有什么特殊的地方，直接上代码

```c++
vector<vector<int>> combinationSum(vector<int>& candicates, int target) {
    vector<vector<int>> ans;
    vector<int> p;
    backtrack(candicates, target, ans, p, 0, 0);
    return ans;
}

void backtrack(vector<int>& c, int t, vector<vector<int>>& ans, vector<int>& p, int sum, int idx) {
    if (sum == target) {
        ans.push_back(p);
        return;
    }
    if(sum > target) return;
    for(int i = idx; i< c.size(); i++) {
        p.push_back(c[i]);
        sum += c[i];
        backtrack(c, t, ans, p, sum, i);
        p.pop_back();
        sum -= c[i];
    }
}
```

46 Permutations
---------------
[LeetCode](https://leetcode.com/problems/permutations)/[力扣](https://leetcode-cn.com/problems/permutations)

Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order

需要有个数组来保存是否已经排列过了，回溯法解决很简单

```c++
vector<vector<int>> permute(vector<int>& nums) {
    vector<int> path;
    vector<bool> exists(nums.size(), false);
    vector<vector<int>> ans;
    backtrack(nums, path, ans, exists);
    return ans;
}
void backtrack(vector<int>& nums, vector<int>& path, vector<vector<int>>& ans, vector<bool>& exists) {
    if(path.size() == nums.size()) {
        ans.push_back(path);
        return;
    }
    for(int i = 0; i < nums.size();i++) {
        if(exists[i] == true) continue;
        path.push_back(nums[i]);
        exists[i] = true;
        backtrack(nums,path,ans,exists);
        exists[i] = false;
        path.pop_back();
    }
}
```