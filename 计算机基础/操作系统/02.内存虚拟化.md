## 地址空间
- 物理内存的抽象，是运行的程序看到的系统中的内存

### 组成
- 程序代码，位于顶部
- 栈 堆和栈反向增长
- 堆
- 其他，如静态初始化的变量

遵循隔离原则，两个实体相互隔离，互不影响

### 虚拟内存目标
- 透明。操作系统实现虚拟内存方式，运行的程序看不见
- 效率。操作系统虚拟化内存尽可能高效，包括时间和空间上
- 保护。操作系统应确保进程受到保护，不受其他进程影响

## 内存操作API
### 内存类型
- 堆内存。申请和释放由程序员完成
- 栈内存。申请和释放由编译器管理

### 堆内存API
- `malloc()` 传入申请堆空间大小，返回一个新申请的空间指针
- `calloc()` 返回之前将其置为零
- `realloc()` 创建一个更大的内存区域，将旧区域复制到其中，并返回新的指针
- `free()` 传入一个指针，释放该指针空间

### 常见错误
- 忘记分配内存
- 没有分配足够的内存
- 忘记初始化分配的内存
- 忘记释放内存
- 在用完之前释放内存
- 反复释放内存
- 错误调用`free()`

### 底层操作系统支持
- `malloc`和`free`是库调用，不是系统调用，但是本身是建立在系统调用之上的
- 系统调用`brk` 用来改变程序分断位置：堆结束的位置
- 系统调用`sbrk` 传入一个增量，目的与`brk`类似

## 地址转换机制
- 地址转换。每次访问内存时，将指令中的虚拟地址转换成实际存储的物理地址
- 假象：每个程序都拥有自己的内存，存放自己的代码和数据

### Interposition
- 一种常见且有用的技术。
- 虚拟内存中，硬件可以介入到每次内存访问中，将进程的虚拟地址转换成实际物理地址
- 最基本的优点是透明

### 转换方式
- 每个CPU需要两个硬件寄存器：基址寄存器和界限寄存器（内存管理单元MMU）
- 基址寄存器将虚拟地址转换成物理地址
- 界限寄存器确保地址在进程地址空间范围内，提供了访问保护

**硬件要求**

|硬件要求|解释|
|---|---|
|特权模式|防止用户模式进程执行特权操作|
|基址/界限寄存器|每个CPU需要一对寄存器来支持地址转换和界限检查|
|能够转换虚拟地址并检查是否越界|电路完成转换和界限检查|
|修改基址/界限寄存器的特权指令|让用户进程运行前，操作系统必须设置这些值|
|注册异常处理程序的特权指令|必须能告诉硬件，如果异常发生，执行哪些代码|
|能够触发异常|如果使用特权指令或内存越界，触发异常|

### 操作系统的指责
- 创建进程时，为进程的地址空间找到内存空间
- 进程终止时，回收所有内存，给其他进程或操作系统使用
- 上下文切换时，保存和恢复基址和界限寄存器

|操作系统要求|解释|
|---|---|
|内存管理|为新进程分配内存，从终止进程回收内存。通过空闲列表`free list`来管理内存|
|基址/界限寄存器管理|上下文切换时，正确设置基址/界限寄存器|
|异常处理|异常发生时，需要进行处理|


## 分段
### 解决的问题
- 内部碎片。分配的内存单元内部有未使用的空间

如果把整个地址空间全都加载到内存，在堆、栈内存使用很少的情况下，整个地址空间就有大部分内存未使用，造成严重的内部碎片

### 原理
- 在MMU中引入不止一个基址和界限寄存器，给每个逻辑段（代码、堆和栈）一对，将不同的段放到不同的物理内存区域，从而避免了内部碎片

非法访问时会造成段错误(segmentation fault)或段异常(segmentation violation)

### 段引用方式
- 转换时，如何知道端内偏移量和地址引用了哪个段
- 显式(explicit)方式。用虚拟地址的开头几位标识不同的段
- 隐式(implicit)方式。硬件通过地址产生方式来确定段

### 栈地址映射
- 栈是反向增长的，所以需要硬件支持知道段的增长方向

### 共享段
- 需要硬件支持，保护位，标识程序是否能够读、写或执行
- 代码段一般是只读的。同样的代码可以被多个进程共享

### 操作系统支持

**分段之后带来的问题**
- 上下文切换时，需要保存和恢复各个段寄存器的内容
- 管理物理内存空闲空间。会造成外部碎片（物理内存有空闲空间，但很难分配给新的段）

**外部碎片解决**
- 紧凑物理内存，重新安排原有的段
- 利用空闲列表管理算法，试图保留大的内存块用于分配（最优匹配、最坏匹配、首次匹配等）

## 空闲空间管理
>主要用来解决外部碎片

### 分配程序通用机制
- 分割与合并
- 追踪已分配空间的大小
- 嵌入空闲列表
- 让堆增长

### 基本策略
- 最优匹配
- 最差匹配
- 首次匹配
- 下次匹配
- 分离空闲列表。经常申请一种大小内存空间，用一个独立的列表，其他交给通用的内存分配
- 伙伴系统。分配内存时，空间递归一分为二，直到刚好可以满足请求的大小

## 分页
>解决的问题：分段以后，空间本身会碎片化，随着时间的推移，分配内存会变得比较困难

分页：将空间分割成固定长度的分片

分页优点：
- 灵活性。通过分页，操作系统能够有效提供地址空间的抽象，不管进程如何使用地址空间
- 简单性。空闲空间管理变得简单

页表：
- 操作系统为每个进程保存的数据结构。地址空间每个虚拟也放在屋里内存中的位置
- 主要作用：为地址空间的每个虚拟页面保存地址转换，将虚拟地址转换成物理地址
- 页表存储在内存中
- 主要数据结构为页号和页面偏移量，可能还有有效位，保护位，存在位，访问位等
- 分页需要执行额外的内存引用，工作量很大，开销很大。另外页表占用内存很大

## 分页地址转换(TLB)
- TLB：地址转换旁路缓冲存储器，其实就是硬件缓存

### 基本算法
- 从虚拟地址提取页号
- 检查TLB是否有该虚拟地址页号的转换映射
- 如果有，从TLB提取页帧号，并计算物理地址，进行访问
- 如果没有，硬件访问页表寻找转换映射，并更新TLB。开销较大


### 缓存局部性
- 时间局部性。最近访问过的指令或数据项，可能很快会再次访问
- 空间局部性。当访问内存地址x时，很快会访问邻近x的内存

### TLB未命中
- 硬件处理
- 软件处理

处理过程：
- 旧体系架构：未命中时，硬件会遍历页表，找到正确页表项，转换并更新TLB。
- 现代体系：未命中时，抛出一个异常，暂停当前指令，然后`trap`,处理完之后，更新TLB

### TLB内容
- 页号VPN
- 页面偏移量PFN
- 其他位

**注意**
- TLB有效位<font color=red>不是</font>页表有效位
- TLB包含的虚拟到物理的地址映射只对当前进程有效，对其他进程是没有意义的
- 上下文切换时TLB处理：方案一 清空TLB，但是开销很大；方案二 添加硬件支持 在TLB中添加一个地址空间标识符，可以减少开销

### TLB替换策略
- LRU(最近最少使用) <font color=red>常用</font>
- 随机策略

## 分页：较小的表
>问题：页表太大，消耗内存太多

### 解决方案
- 使用更大的页
- 混合方法：分页和分段
- 多级页表
- 反向页表。使用散列表加速搜索的速度

### 分页和分段实现
- 不是为进程整个空间提供单个页表，为每个逻辑段提供一个页表（代码、堆和段）
- 分段基址寄存器不是指向段本身，而是段的页表的物理地址，界限寄存器指向页表结尾

### 多级页表实现
- 将页表分成页大小的单元
- 如果整页的页表项无效，完全不分配该页的页表
- 使用页目录的结构，追踪页表的页是否有效

**优缺点**
- 非常紧凑，支持稀疏的地址空间
- 页表每个部分可以整齐放入一页中，更容易管理内存
- TLB未命中时，需要从内存加载两次，才能获取正确地址（一次页目录，一次用于PTE本身）

## 超越物理内存:机制
>解决问题：为了使用更大的地址空间

**交换空间**
- 硬盘上开辟一部分空间用于物理页的移入和移出
- 决定了系统在某一时刻能够使用的最大内存页数

**存在位**
- 如果TLB和PFN中都没有VPN时，需要从物理硬盘置换到物理内存
- 用一个存在位保存是否存在内存中，如果不在，就会发生一个也错误(page fault)

**页错误**
- 由操作系统来管理

## 参考文献
- 操作系统导论