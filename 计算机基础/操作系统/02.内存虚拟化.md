## 地址空间
- 物理内存的抽象，是运行的程序看到的系统中的内存

### 组成
- 程序代码，位于顶部
- 栈 堆和栈反向增长
- 堆
- 其他，如静态初始化的变量

遵循隔离原则，两个实体相互隔离，互不影响

### 虚拟内存目标
- 透明。操作系统实现虚拟内存方式，运行的程序看不见
- 效率。操作系统虚拟化内存尽可能高效，包括时间和空间上
- 保护。操作系统应确保进程受到保护，不受其他进程影响

## 内存操作API
### 内存类型
- 堆内存。申请和释放由程序员完成
- 栈内存。申请和释放由编译器管理

### 堆内存API
- `malloc()` 传入申请堆空间大小，返回一个新申请的空间指针
- `calloc()` 返回之前将其置为零
- `realloc()` 创建一个更大的内存区域，将旧区域复制到其中，并返回新的指针
- `free()` 传入一个指针，释放该指针空间

### 常见错误
- 忘记分配内存
- 没有分配足够的内存
- 忘记初始化分配的内存
- 忘记释放内存
- 在用完之前释放内存
- 反复释放内存
- 错误调用`free()`

### 底层操作系统支持
- `malloc`和`free`是库调用，不是系统调用，但是本身是建立在系统调用之上的
- 系统调用`brk` 用来改变程序分断位置：堆结束的位置
- 系统调用`sbrk` 传入一个增量，目的与`brk`类似

## 地址转换机制
- 地址转换。每次访问内存时，将指令中的虚拟地址转换成实际存储的物理地址
- 假象：每个程序都拥有自己的内存，存放自己的代码和数据

### Interposition
- 一种常见且有用的技术。
- 虚拟内存中，硬件可以介入到每次内存访问中，将进程的虚拟地址转换成实际物理地址
- 最基本的优点是透明

### 转换方式
- 每个CPU需要两个硬件寄存器：基址寄存器和界限寄存器（内存管理单元MMU）
- 基址寄存器将虚拟地址转换成物理地址
- 界限寄存器确保地址在进程地址空间范围内，提供了访问保护

**硬件要求**

|硬件要求|解释|
|---|---|
|特权模式|防止用户模式进程执行特权操作|
|基址/界限寄存器|每个CPU需要一对寄存器来支持地址转换和界限检查|
|能够转换虚拟地址并检查是否越界|电路完成转换和界限检查|
|修改基址/界限寄存器的特权指令|让用户进程运行前，操作系统必须设置这些值|
|注册异常处理程序的特权指令|必须能告诉硬件，如果异常发生，执行哪些代码|
|能够触发异常|如果使用特权指令或内存越界，触发异常|

### 操作系统的指责
- 创建进程时，为进程的地址空间找到内存空间
- 进程终止时，回收所有内存，给其他进程或操作系统使用
- 上下文切换时，保存和恢复基址和界限寄存器

|操作系统要求|解释|
|---|---|
|内存管理|为新进程分配内存，从终止进程回收内存。通过空闲列表`free list`来管理内存|
|基址/界限寄存器管理|上下文切换时，正确设置基址/界限寄存器|
|异常处理|异常发生时，需要进行处理|


## 分段
### 解决的问题
- 内部碎片。分配的内存单元内部有未使用的空间
- 

## 参考文献
- 操作系统导论