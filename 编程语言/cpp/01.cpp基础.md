## 数据类型
**基本类型**

- 整型(int) 4字节
- 单精度浮点型(float) 4字节
- 双精度浮点型(double) 8字节
- 布尔型(bool) 1字节
- 字符型(char) 1字节
- 无类型(void)
- 宽字符型(wchar_t) 2或4字节 `typedef short int wchar_t;`
  
**扩展类型**

- 枚举类型(enum)
- 结构体(struct)
- 联合体(union)

基本类型可以使用一个或多个修饰符进行修饰，如：`signed` `unsigned` `short` `long`
- `signed`和`unsigned`不改变类型空间大小
- `short`修饰占用空间为2个字节
- `long`增加为2倍字节大小
- 可以使用`sizeof()`获取字节长度，但是需要清楚了解每个大小，面试经常问

### 枚举类型
**限定作用域**

```cpp
enum class open_modes {input, output, append};
```

**不限定作用域**

```cpp
enum color{red, yellow, green};
enum {floatPrec = 6, doublePrec = 10};
```

### 结构体
**`struct`和`typedef struct`**

```cpp
typedef struct Student {
    int age;
} S;
```
等价于
```cpp
struct Student {
    int age;
};
typedef struct Student S;
```

**`struct`和`class`**

- 继承访问权限：`struct`默认是`public`,`class`默认是`private`
- 内部成员访问权限：`struct`是`public`,`class`是`private`

**字节对齐**

各个硬件平台对存储空间的处理上有很大不同，保证字节对齐可以兼容各个硬件平台，但是会在存取效率上带来损失

内存对齐规则：
- 结构体各个成员，第一个偏移量是0，排列在后面的成员其当前的偏移量必须是当前成员类型的整数倍
- 结构体占用内存大小是体内最大数据成员的最小倍数
- 如程序中有`#pragma pack(n)`预编译指令，所有成员对齐以`n`字节为准（偏移量是`n`的整数倍），不再考虑当前类型以及结构体内最大类型

具体可以参考[内存对齐规则之我见](https://levphy.github.io/2017/03/23/memory-alignment.html)

### 联合体
- 默认访问控制为`public`
- 可以含有构造函数和析构函数
- 不能含有引用类型成员
- 不能继承，不能被继承
- 不能含有虚函数
- 匿名`union`在定义所在作用域可直接访问成员
- 匿名`union`不能包含`protected`和`private`成员
- 全局匿名`union`必须是`static`的


## 关键字
### const
- 修饰变量，说明变量不可以被改变
- 修饰指针，指向常量的指针(`const char*`)和指针常量(`char* const`)
- 修饰引用，指向常量的引用，避免拷贝又避免函数对值修改
- 修饰成员函数，该成员函数内部不能修改成员变量

>被const修饰(在const后面)的值不可改变

### static
- 修饰普通变量，修改变量存储区和生命周期，使变量在静态区，在`main`函数运行前就分配了空间，默认会会初始化
- 修饰普通函数，表明函数作用范围，仅定义该函数的文件内才能使用
- 修饰成员变量，使所有的对象只保存一个该变量，不需要对象就可以访问该成员
- 修饰成员函数，不需要对象就可以访问，但是`static`函数内不能访问非静态成员

### this
- `this`是一个隐含于每一个非静态成员函数中的一个特殊指针，指向调用该成员函数的那个对象
- 每次调用成员函数时，编译程序先将对象的地址赋给`this`指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用`this`指针
- `this`指针被隐式声明为`ClassName *const this`，意味着不能给`this`赋值，不可修改
- `this`是一个右值，不能取得`this`的地址
- 需要显式引用`this`指针：对象的链式引用；避免同一对象进行赋值操作；实现一些数据结构时

### inline
**特征**

- 把内联函数里面的内容写在调用内联函数处
- 不用执行进入函数的步骤，直接执行函数体
- 相当于宏，比宏多了类型检查，具有函数特性
- 编译器一般不内联包含循环、递归、switch等复杂操作的内联函数
- 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式当成内联函数

**编译器处理**

- 编译器会把函数体复制到`inline`函数调用点处
- 编译器为所用`inline`函数中的局部变量分配内存空间
- 编译器将`inline`函数所有的输入参数和返回值映射到调用方法的局部变量空间中
- 如果有多个返回点，编译器会将其变为`inline`函数代码块末尾的分支

**优缺点**

- 省去了参数压栈、栈帧开辟与回收，提高运行速度
- 会做安全检查，宏不会
- 内联函数可以访问类的成员变量，宏不能
- 内联函数运行时可调试，宏不能
- 代码会膨胀
- 是否内联，程序不可控。内联函数只是对编译器的建议，决定权在于编译器
- 虚函数可以时内联函数，但虚函数表现多态性时不能内联（因为编译期内联，运行时多态）

### volatile
- 声明的类型变量可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改，所以使用`volatile`告诉编译器不应该对这样的对象进行优化
- `volatile`声明的变量，每次访问时必须从内存中取值，没有被`volatile`修饰的变量，可能由于编译器的优化，从CPU寄存器取值
- `const`可以是`volatile` 只读状态寄存器
- 指针可以是`volatile`

### assert
- 是宏，而非函数
- 如果条件返回错误，终止程序执行
- 可以通过`NDEBUG`关闭`assert`，但需要在源代码的开头，`include <assert.h>`之前

### explicit
- `explicit`修饰构造函数时，可以防止隐式转换和复制初始化
- `explicit`修饰转换函数时，可以防止隐式转换，单按语境转换除外

### friend
- 能访问私有成员
- 破坏封装性
- 不可传递
- 单向性
- 声明形式及数量不受限制

### using
- `using`声明 引入命名空间的一个成员 `using namespace_name::name;`
- `using`指示，使得特定命名空间的所有名字都可见 `using namespace name;`
- 尽量少使用`using`指示，使用声明更安全且不会包含不需要的名称

### decltype
- 用于检查实体的声明类型或表达式的类型及值分类

```cpp
template<typename It>
auto fcn(It beg, It end) -> decltype(*beg)
{
    //todo
    return *beg;
}
template<typename It>
auto fnc2(It beg, It end) -> typename remove_referenct<decltype(*beg)>::type
{
    //todo
    return *beg;
}
```

## 面向对象
### 封装

### 继承

### 多态

### 虚析构函数

### 虚函数和纯虚函数

### 虚函数指针和虚函数表

### 虚继承

### 模板类和成员模板

### 抽象类、接口类和聚合类


## 参考文献
[C++面试](https://interview.huihut.com/#/?id=%e2%9e%95-cc)